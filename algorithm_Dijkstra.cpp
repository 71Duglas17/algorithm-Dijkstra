#include <iostream>
#include <fstream>
#include <locale.h>
#include <stdlib.h>
#include <string>
#include <stdio.h>
#include <time.h> 
using namespace std;
int main()
{
	setlocale(LC_ALL, "Russian");
	clock_t start, final;
	start = clock();
	int n, i, j, a, b;
	string str[501];
	fstream f;
	f.open("input.txt", ios_base::in);
	if (!f.is_open())
		cout << "Ошибка открытия файла! ";
	else
	{
		f >> n;
		cout << "Кол-во вершин в графе: " << n;
		for (i = 0; i < n * n; i++)
		{
			f >> str[i]; // считываем с файла матрицу расстояний в строку
			if (str[i] == "~") // если попался знак тильда, то меняем его на -1
				str[i] = "-1";
		}
		f >> a;
		f >> b;
	}
	f.close();
	int* x0; // одномерный массив, где будет храниться матрица расстояний
	x0 = new int[n * n];
	for (i = 0; i < n * n; i++) // обнуляем массив для начала работы
		x0[i] = 0;
	for (i = 0; i < n * n; i++) // переводим строчный тип данных в числовой
		x0[i] = atoi(str[i].c_str());
	int** x;
	x = new int* [n]; // двумерный массив, где будет храниться матрица расстояний
	for (i = 0; i < n; i++)
		x[i] = new int[n];
	for (i = 0; i < n; i++) // обнуляем массив
		for (j = 0; j < n; j++)
			x[i][j] = 0;
	int k = 0; // число к нужно для перевода одномерного массива в двумерный
	for (i = 0; i < n; i++)
		for (j = 0; j < n; j++)
		{
			x[i][j] = x0[k];
			k++;
		}
	cout << "\nГраф, записанный в виде матрицы смежности: " << endl;
	for (i = 0; i < n; i++)
	{
		for (j = 0; j < n; j++)
			cout << x[i][j] << "\t";
		cout << endl;
	}
	cout << "\nНачальная и конечная вершина: " << a << " " << b; // a и b - вершины, расстояние и путь между которыми надо найти

	// т.к. размер used равен всего 10, то алгоритм не работает если вершин больше 10 (из за этого мне снизили баллы по дискретке)
	// сделать размер по больше
	bool used[10]; // логическая переменная, к/т показывает, посещали ли мы вершину или нет
	for (i = 0; i < n; i++) // изначально все вершины не посещены, поэтому 0 (false)
		used[i] = 0;
	a = a - 1; // т.к. нумирация в массиве идет с нуля
	int* ver; // массив, где будут записаны расстояния от заданной вершины до других вершин
	ver = new int[n];
	for (j = 0; j < n; j++) // заполняем массив большими числами, т.к. вершины мы ещё не посещали
		ver[j] = 9999;
	ver[a] = 0;     // вес начальной веришны равен нулю, т.к. с нее мы начинаем
	int min;  // вес минимальной вершины
	int cur = 9999; // индекс вершины с минимальным весом
	int temp; // вспомогательная переменная


	// алгоритм Дейкстры
	// поиск наименьшего расстояния
	do
	{
		min = 9999; // делаем большие значения, чтобы при сравнении с весом вершин, вес вершин был ТОЧНО меньше 9999 (иначе выход из цикла)
		cur = 9999;
		for (j = 0; j < n; j++)
			if (used[j] == 0 && ver[j] < min) // ищем минимальное значение среди непосещенных вершин
			{
				min = ver[j]; // запоминаем вес этой вершины
				cur = j; // запоминаем идекс текущей вершины, с которой будем дальше работать
			}
		if (cur != 9999) // если мы нашли ещё не посещенную веришину
		{
			for (i = 0; i < n; i++)
			{
				if (x[cur][i] > 0) // если две вершины связаны между собой ребром, или если вершина не связана сама с собой
				{
					temp = min + x[cur][i];
					if (ver[i] > temp) // если сумма минимальной вершины и расстояния от текущей вершины до соседней оказалось меньше веса соседней вершины,
					{
						ver[i] = temp; // то нашли меньшее растояние до соседней вершины => присваиваем соседней вершине вес равный сумме
					}
				}
			}
			used[cur] = 1; // данную вершину мы посетили и больше к ней не возвращаемся
		}
	} while (cur < 9999); // когда все вершины будут посещены, то cur останется равной 9999 => выходим из цикла


	cout << "\nРасстояние от вершины " << a + 1 << " до вершины " << b << " равно " << ver[b - 1];
	int* path; // массив, где будет храниться путь от вершины а до вершины b
	path = new int[n];
	for (i = 0; i < n; i++)
		path[i] = 0;
	int end = b - 1; // запоминаем индекс вершины до которой ищем путь
	path[0] = end + 1; // искать путь будем с конца, поэтому первым элементом массива будет конечная вершина
	int w = ver[end]; // вес конечной вершины
	temp = 0;
	int index = 1; // индекс предыдущей вершины


	// поиск наикратчайшего пути между двумя вершинами
	// идем с конца
	while (end != a) // цикл завершится, когда конечная вершина будет равна начальной
	{
		for (i = 0; i < n; i++)
		{
			if (x[i][end] > 0) // если у конечной вершины есть соседи
			{
				temp = w - x[i][end]; // вычитаем из веса конечной вершины вес ребра, которое соединяет конечной вершины с соседней
				if (temp == ver[i]) // если эта разность совпала с весом соседней вершины, то это значит, что мы нашли предыдущую вершину (следующую с конца)
				{
					w = temp; // запоминаем вес это вершины
					end = i; // запоминаем индекс этой вершины и конечной вершиной теперь становится данная вершина
					path[index] = i + 1; // записываем найденную вершину в массив
					index++;
				}
			}
		}
	}

	cout << "\nПуть от вершины " << a + 1 << " до веришны " << b << ":   ";
	for (i = index - 1; i > -1; i--) // выводим путь в обратном порядке
		cout << path[i] << "\t";
	f.open("output.txt", ios_base::out);
	if (!f.is_open())
		cout << "Ошибка открытия файла! ";
	else
	{
		f << ver[b - 1]; // записываем расстояние между заданными веришнами в файл output
		f << "\n";
		for (i = index - 1; i > -1; i--)  // записываем путь между заданными вершинами в файл
			f << path[i] << " ";
	}
	f.close();
	cout << endl;
	delete[] x0;
	delete[] x;
	delete[] ver;
	delete[] path;
	final = clock(); // подсчитываем время работы программы
	printf("\nThe above code block was executed in %.4f second(s)\n", ((double)final - start) / ((double)CLOCKS_PER_SEC));
	return 0;
}